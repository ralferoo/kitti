<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

var numFilesLoaded;
var people;
var known_identifiers;
var log_lines;
var transaction_matrix;
var totalEverCredited;

function getAsync( url, callback ) {
    var http = new XMLHttpRequest();
    // need to always request a different URL to avoid getting a cached copy
    http.open( 'GET', url + ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime(), true );
    http.onreadystatechange = function() {
        if( http.readyState==4 && http.status==200 ) {
            callback( http.responseText );
            checkAllLoaded();
        }
    };
    http.send();
}

function storeNames( text ) {
    name_lines = text.split("\n");
    for( var i = 0; i < name_lines.length; ++i ) {
        entries = name_lines[i].split(':');
        if( entries.length < 2 ) {
            continue;
        }
        var initial = entries[0];
        people[ initial ] = new Object();
        people[ initial ].full = entries[1];
        people[ initial ].credit = 0.0;
        known_identifiers.push( initial );
    }
    for( var i = 0; i < known_identifiers.length; ++i ) {
        transaction_matrix[i] = [];
        for( var j = 0; j < known_identifiers.length; ++j ) {
            transaction_matrix[i][j] = 0.0;
        }
    }
}

function storeLog( text ) {
    log_lines = text.split("\n");
}

function checkAllLoaded() {
    numFilesLoaded += 1;
    if( numFilesLoaded == 2 ) {
        processData();
    }
}

function clearData() {
    numFilesLoaded = 0;
    people = new Object();
    known_identifiers = new Array();
    log_lines = new Array();
    transaction_matrix = [];
    totalEverCredited = 0;
}

function requestFreshData() {
    clearData();
    if( true ) {
        getAsync( "http://rawles.github.io/kitti/kittilog.txt", storeLog );
        getAsync( "http://rawles.github.io/kitti/names.txt", storeNames );
    }
    else {
        // useful for local debugging
        storeLog( "2014-07-25T13:30  FB20F15B     Bedouin lunch\n2014-07-29T21:10  PFB16.48B2F  Cherry Box Pizza on film night\n2014-07-31T20:30  BF8F         Cambridge Blue (Benediktiner Weissbier)\n2014-07-31T22:00  BF36.60F     Ohayu Sushi" );
        storeNames( "F:Fergal\nB:Bear\nP:Pup\nT:Turtle\nM:Monkey\nH:Hannah" );
        processData();
    }
}

function parseLine( line ) {

    if( !line.match( /\S/g ) ) {
        return; // blank line, ignore
    }

    var comments = new Array();

    var allowed_identifiers = "(?:" + known_identifiers.join('|') + ")";
    var allowed_currencies = "[DE]";
    var float_match = "([\\d\\.]+)";
    var percentage_or_amount = "(?:" + float_match + "(?:\\%)|" + float_match + ")"; // float% or float
    var bracketed_percentage_or_amount = "(?:\\(" + percentage_or_amount + "\\)|\\[" + percentage_or_amount + "\\])"; // (val) or [val]
    var debtor_match = "(" + allowed_identifiers + ")(?:" + bracketed_percentage_or_amount + ")?";
    var creditor_match = "(" + allowed_currencies + ")?(?:" + float_match + ")(" + allowed_identifiers + ")";
    var transaction_match = "(" + debtor_match + ")|(" + creditor_match + ")";
    var line_match = "^(?:\\S+\\s+)(\\S+)(?:\\s+)(.+)$";

    var line_tokens = line.match( new RegExp( line_match ) );
    if( !line_tokens || line_tokens.length != 3 ) {
        comments.push( 'ERROR: Failed to parse this line at all.' );
        return comments;
    }
    var transaction = line_tokens[1];
    var description = line_tokens[2];
    var transaction_tokens = transaction.match( new RegExp( transaction_match, "gi" ) );
    if( !transaction_tokens || transaction_tokens.length < 2 ) {
        comments.push( 'ERROR: Failed to parse this transaction.' );
        return comments;
    }

    var totalCredited = 0.0;
    var weightedDebtors = new Object();
    var totalWeighting = 0.0;
    var fixedDebtors = new Object();
    for( var j in transaction_tokens ) {
        var token = transaction_tokens[j];
        var creditor_subtokens = token.match( new RegExp( creditor_match, "i" ) );
        var debtor_subtokens = token.match( new RegExp( debtor_match, "i" ) );
        if( creditor_subtokens ) {
            // this is an amount credited
            creditCurrency = creditor_subtokens[1];
            if( creditCurrency ) {
                comments.push( 'ERROR: Cannot process foreign currency in this version!' );
                return comments;
            }
            creditAmount = parseFloat( creditor_subtokens[2] );
            initial = creditor_subtokens[3];
            people[ initial ].credit += creditAmount;
            totalCredited += creditAmount;
            comments.push( 'CREDIT: '+people[initial].full+' gets +'+creditAmount+' ukp.' );
        }
        else if( debtor_subtokens ) {
            initial = debtor_subtokens[1];
            percentage = parseFloat( debtor_subtokens[2] );
            debitAmount = parseFloat( debtor_subtokens[5] );
            if( debitAmount ) {
                fixedDebtors[ initial ] = debitAmount; // (don't debit yet in case currency is not ukp)
            }
            else if( percentage ) {
                var weight = percentage / 100.0;
                totalWeighting += weight;
                weightedDebtors[ initial ] = weight;
            }
            else {
                var weight = 1.0;
                totalWeighting += weight;
                weightedDebtors[ initial ] = weight;
            }
        }
    }
    var remainingDebt = totalCredited;
    for( var initial in fixedDebtors ) {
        var debitAmount = fixedDebtors[ initial ];
        people[ initial ].credit -= debitAmount;
        remainingDebt -= debitAmount;
        comments.push( 'DEBIT: '+people[initial].full+' gets -'+debitAmount.toFixed(2)+' ukp (fixed amount).' );
    }
    var unitDebt = remainingDebt / totalWeighting;
    for( var initial in weightedDebtors ) {
        var weight = weightedDebtors[ initial ];
        var debitAmount = unitDebt * weight;
        people[ initial ].credit -= debitAmount;
        comments.push( 'DEBIT: '+people[initial].full+' gets -'+debitAmount.toFixed(2)+' ukp (share weighted by '+weight.toFixed(2)+').' );
    }
    incrementTransactionMatrix( totalCredited, fixedDebtors, weightedDebtors );
    return comments;
}

function incrementTransactionMatrix( totalCredited, fixedDebtors, weightedDebtors ) {
    var people_involved = [];
    for( var initial in fixedDebtors ) {
        var iPerson = known_identifiers.indexOf( initial );
        people_involved.push( iPerson );
    }
    for( var initial in weightedDebtors ) {
        var iPerson = known_identifiers.indexOf( initial );
        people_involved.push( iPerson );
    }
    for( var i in people_involved ) {
        for( var j in people_involved ) {
            if( j<=i ) { continue; }
            transaction_matrix[i][j] += totalCredited;
            transaction_matrix[j][i] += totalCredited;
        }
    }
    totalEverCredited += totalCredited;
}

function computeFuturePredictions() {
    var N = transaction_matrix.length;
    // normalize the transactions matrix
    for( var i = 0; i < N; ++i ) {
        for( var j = 0; j < N; ++j ) {
            transaction_matrix[i][j] /= totalEverCredited;
        }
    }
}

function printStatus() {
    var html = "<table align=\"center\" border=\"0\" cellspacing=\"10\">";
    for( var initial in people ) {
        var person = people[ initial ];
        html += "<tr><td>" + person.full + "</td><td>" + person.credit.toFixed(2) + "</td></tr>";
    }
    // TODO: sort to put lowest first, debts in red, pound symbol
    html += "</table>";
    
    html += "<h4>Transaction matrix:</h4><table border=\"1\">";
    for( var row in transaction_matrix ) {
        html += "<tr><td>"+transaction_matrix[row].map(function(x){ return x.toFixed(2); }).join("</td><td>") + "</td></tr>";
    }
    html += "</table>";
    return html;
}

function processData() {
    var log_html = "<h4>Parsed transactions:</h4><table border=\"1\">";
    for( var i in log_lines ) {
        var line = log_lines[i];
        var comments = parseLine( line );
        if( comments ) {
            log_html += "<tr><td><b>"+line+"</b></td><td>"+comments.join("<br>")+"</td></tr>";
        }
    }
    log_html += "</table>";
    computeFuturePredictions();
    document.getElementById("currentStatus").innerHTML = printStatus();
    document.getElementById("log").innerHTML = log_html;
}

window.onload = requestFreshData;
setInterval( requestFreshData, 10000 ); // update data every 10s

</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>
<body>

<div id="currentStatus">status</div>

<div id="log">log</div>

    
</body>
</html>
